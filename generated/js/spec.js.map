{
  "version": 3,
  "file": "spec.js",
  "sources": [
    "spec/helpers/helper.js",
    "spec/helpers/jasmine-fixture.js",
    "spec/helpers/jasmine-given.js",
    "spec/helpers/jasmine-only.js",
    "spec/helpers/jasmine-stealth.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;A;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A",
  "sourcesContent": [
    "window.context = window.describe;\nwindow.xcontext = window.xdescribe;\n",
    "/* jasmine-fixture - 1.3.2\n * Makes injecting HTML snippets into the DOM easy & clean!\n * https://github.com/searls/jasmine-fixture\n */\n(function() {\n  var createHTMLBlock,\n    __slice = [].slice;\n\n  (function($) {\n    var ewwSideEffects, jasmineFixture, originalAffix, originalJasmineDotFixture, originalJasmineFixture, root, _, _ref;\n    root = (1, eval)('this');\n    originalJasmineFixture = root.jasmineFixture;\n    originalJasmineDotFixture = (_ref = root.jasmine) != null ? _ref.fixture : void 0;\n    originalAffix = root.affix;\n    _ = function(list) {\n      return {\n        inject: function(iterator, memo) {\n          var item, _i, _len, _results;\n          _results = [];\n          for (_i = 0, _len = list.length; _i < _len; _i++) {\n            item = list[_i];\n            _results.push(memo = iterator(memo, item));\n          }\n          return _results;\n        }\n      };\n    };\n    root.jasmineFixture = function($) {\n      var $whatsTheRootOf, affix, create, jasmineFixture, noConflict;\n      affix = function(selectorOptions) {\n        return create.call(this, selectorOptions, true);\n      };\n      create = function(selectorOptions, attach) {\n        var $top;\n        $top = null;\n        _(selectorOptions.split(/[ ](?![^\\{]*\\})(?=[^\\]]*?(?:\\[|$))/)).inject(function($parent, elementSelector) {\n          var $el;\n          if (elementSelector === \">\") {\n            return $parent;\n          }\n          $el = createHTMLBlock($, elementSelector);\n          if (attach || $top) {\n            $el.appendTo($parent);\n          }\n          $top || ($top = $el);\n          return $el;\n        }, $whatsTheRootOf(this));\n        return $top;\n      };\n      noConflict = function() {\n        var currentJasmineFixture, _ref1;\n        currentJasmineFixture = jasmine.fixture;\n        root.jasmineFixture = originalJasmineFixture;\n        if ((_ref1 = root.jasmine) != null) {\n          _ref1.fixture = originalJasmineDotFixture;\n        }\n        root.affix = originalAffix;\n        return currentJasmineFixture;\n      };\n      $whatsTheRootOf = function(that) {\n        if ((that != null ? that.jquery : void 0) != null) {\n          return that;\n        } else if ($('#jasmine_content').length > 0) {\n          return $('#jasmine_content');\n        } else {\n          return $('<div id=\"jasmine_content\"></div>').appendTo('body');\n        }\n      };\n      jasmineFixture = {\n        affix: affix,\n        create: create,\n        noConflict: noConflict\n      };\n      ewwSideEffects(jasmineFixture);\n      return jasmineFixture;\n    };\n    ewwSideEffects = function(jasmineFixture) {\n      var _ref1;\n      if ((_ref1 = root.jasmine) != null) {\n        _ref1.fixture = jasmineFixture;\n      }\n      $.fn.affix = root.affix = jasmineFixture.affix;\n      return afterEach(function() {\n        return $('#jasmine_content').remove();\n      });\n    };\n    if ($) {\n      return jasmineFixture = root.jasmineFixture($);\n    } else {\n      return root.affix = function() {\n        var nowJQueryExists;\n        nowJQueryExists = window.jQuery || window.$;\n        if (nowJQueryExists != null) {\n          jasmineFixture = root.jasmineFixture(nowJQueryExists);\n          return affix.call.apply(affix, [this].concat(__slice.call(arguments)));\n        } else {\n          throw new Error(\"jasmine-fixture requires jQuery to be defined at window.jQuery or window.$\");\n        }\n      };\n    }\n  })(window.jQuery || window.$);\n\n  createHTMLBlock = (function() {\n    var bindData, bindEvents, parseAttributes, parseClasses, parseContents, parseEnclosure, parseReferences, parseVariableScope, regAttr, regAttrDfn, regAttrs, regCBrace, regClass, regClasses, regData, regDatas, regEvent, regEvents, regExclamation, regId, regReference, regTag, regTagNotContent, regZenTagDfn;\n    createHTMLBlock = function($, ZenObject, data, functions, indexes) {\n      var ZenCode, arr, block, blockAttrs, blockClasses, blockHTML, blockId, blockTag, blocks, el, el2, els, forScope, indexName, inner, len, obj, origZenCode, paren, result, ret, zc, zo;\n      if ($.isPlainObject(ZenObject)) {\n        ZenCode = ZenObject.main;\n      } else {\n        ZenCode = ZenObject;\n        ZenObject = {\n          main: ZenCode\n        };\n      }\n      origZenCode = ZenCode;\n      if (indexes === undefined) {\n        indexes = {};\n      }\n      if (ZenCode.charAt(0) === \"!\" || $.isArray(data)) {\n        if ($.isArray(data)) {\n          forScope = ZenCode;\n        } else {\n          obj = parseEnclosure(ZenCode, \"!\");\n          obj = obj.substring(obj.indexOf(\":\") + 1, obj.length - 1);\n          forScope = parseVariableScope(ZenCode);\n        }\n        while (forScope.charAt(0) === \"@\") {\n          forScope = parseVariableScope(\"!for:!\" + parseReferences(forScope, ZenObject));\n        }\n        zo = ZenObject;\n        zo.main = forScope;\n        el = $();\n        if (ZenCode.substring(0, 5) === \"!for:\" || $.isArray(data)) {\n          if (!$.isArray(data) && obj.indexOf(\":\") > 0) {\n            indexName = obj.substring(0, obj.indexOf(\":\"));\n            obj = obj.substr(obj.indexOf(\":\") + 1);\n          }\n          arr = ($.isArray(data) ? data : data[obj]);\n          zc = zo.main;\n          if ($.isArray(arr) || $.isPlainObject(arr)) {\n            $.map(arr, function(value, index) {\n              var next;\n              zo.main = zc;\n              if (indexName !== undefined) {\n                indexes[indexName] = index;\n              }\n              if (!$.isPlainObject(value)) {\n                value = {\n                  value: value\n                };\n              }\n              next = createHTMLBlock($, zo, value, functions, indexes);\n              if (el.length !== 0) {\n                return $.each(next, function(index, value) {\n                  return el.push(value);\n                });\n              }\n            });\n          }\n          if (!$.isArray(data)) {\n            ZenCode = ZenCode.substr(obj.length + 6 + forScope.length);\n          } else {\n            ZenCode = \"\";\n          }\n        } else if (ZenCode.substring(0, 4) === \"!if:\") {\n          result = parseContents(\"!\" + obj + \"!\", data, indexes);\n          if (result !== \"undefined\" || result !== \"false\" || result !== \"\") {\n            el = createHTMLBlock($, zo, data, functions, indexes);\n          }\n          ZenCode = ZenCode.substr(obj.length + 5 + forScope.length);\n        }\n        ZenObject.main = ZenCode;\n      } else if (ZenCode.charAt(0) === \"(\") {\n        paren = parseEnclosure(ZenCode, \"(\", \")\");\n        inner = paren.substring(1, paren.length - 1);\n        ZenCode = ZenCode.substr(paren.length);\n        zo = ZenObject;\n        zo.main = inner;\n        el = createHTMLBlock($, zo, data, functions, indexes);\n      } else {\n        blocks = ZenCode.match(regZenTagDfn);\n        block = blocks[0];\n        if (block.length === 0) {\n          return \"\";\n        }\n        if (block.indexOf(\"@\") >= 0) {\n          ZenCode = parseReferences(ZenCode, ZenObject);\n          zo = ZenObject;\n          zo.main = ZenCode;\n          return createHTMLBlock($, zo, data, functions, indexes);\n        }\n        block = parseContents(block, data, indexes);\n        blockClasses = parseClasses($, block);\n        if (regId.test(block)) {\n          blockId = regId.exec(block)[1];\n        }\n        blockAttrs = parseAttributes(block, data);\n        blockTag = (block.charAt(0) === \"{\" ? \"span\" : \"div\");\n        if (ZenCode.charAt(0) !== \"#\" && ZenCode.charAt(0) !== \".\" && ZenCode.charAt(0) !== \"{\") {\n          blockTag = regTag.exec(block)[1];\n        }\n        if (block.search(regCBrace) !== -1) {\n          blockHTML = block.match(regCBrace)[1];\n        }\n        blockAttrs = $.extend(blockAttrs, {\n          id: blockId,\n          \"class\": blockClasses,\n          html: blockHTML\n        });\n        el = $(\"<\" + blockTag + \">\", blockAttrs);\n        el.attr(blockAttrs);\n        el = bindEvents(block, el, functions);\n        el = bindData(block, el, data);\n        ZenCode = ZenCode.substr(blocks[0].length);\n        ZenObject.main = ZenCode;\n      }\n      if (ZenCode.length > 0) {\n        if (ZenCode.charAt(0) === \">\") {\n          if (ZenCode.charAt(1) === \"(\") {\n            zc = parseEnclosure(ZenCode.substr(1), \"(\", \")\");\n            ZenCode = ZenCode.substr(zc.length + 1);\n          } else if (ZenCode.charAt(1) === \"!\") {\n            obj = parseEnclosure(ZenCode.substr(1), \"!\");\n            forScope = parseVariableScope(ZenCode.substr(1));\n            zc = obj + forScope;\n            ZenCode = ZenCode.substr(zc.length + 1);\n          } else {\n            len = Math.max(ZenCode.indexOf(\"+\"), ZenCode.length);\n            zc = ZenCode.substring(1, len);\n            ZenCode = ZenCode.substr(len);\n          }\n          zo = ZenObject;\n          zo.main = zc;\n          els = $(createHTMLBlock($, zo, data, functions, indexes));\n          els.appendTo(el);\n        }\n        if (ZenCode.charAt(0) === \"+\") {\n          zo = ZenObject;\n          zo.main = ZenCode.substr(1);\n          el2 = createHTMLBlock($, zo, data, functions, indexes);\n          $.each(el2, function(index, value) {\n            return el.push(value);\n          });\n        }\n      }\n      ret = el;\n      return ret;\n    };\n    bindData = function(ZenCode, el, data) {\n      var datas, i, split;\n      if (ZenCode.search(regDatas) === 0) {\n        return el;\n      }\n      datas = ZenCode.match(regDatas);\n      if (datas === null) {\n        return el;\n      }\n      i = 0;\n      while (i < datas.length) {\n        split = regData.exec(datas[i]);\n        if (split[3] === undefined) {\n          $(el).data(split[1], data[split[1]]);\n        } else {\n          $(el).data(split[1], data[split[3]]);\n        }\n        i++;\n      }\n      return el;\n    };\n    bindEvents = function(ZenCode, el, functions) {\n      var bindings, fn, i, split;\n      if (ZenCode.search(regEvents) === 0) {\n        return el;\n      }\n      bindings = ZenCode.match(regEvents);\n      if (bindings === null) {\n        return el;\n      }\n      i = 0;\n      while (i < bindings.length) {\n        split = regEvent.exec(bindings[i]);\n        if (split[2] === undefined) {\n          fn = functions[split[1]];\n        } else {\n          fn = functions[split[2]];\n        }\n        $(el).bind(split[1], fn);\n        i++;\n      }\n      return el;\n    };\n    parseAttributes = function(ZenBlock, data) {\n      var attrStrs, attrs, i, parts;\n      if (ZenBlock.search(regAttrDfn) === -1) {\n        return undefined;\n      }\n      attrStrs = ZenBlock.match(regAttrDfn);\n      attrs = {};\n      i = 0;\n      while (i < attrStrs.length) {\n        parts = regAttr.exec(attrStrs[i]);\n        attrs[parts[1]] = \"\";\n        if (parts[3] !== undefined) {\n          attrs[parts[1]] = parseContents(parts[3], data);\n        }\n        i++;\n      }\n      return attrs;\n    };\n    parseClasses = function($, ZenBlock) {\n      var classes, clsString, i;\n      ZenBlock = ZenBlock.match(regTagNotContent)[0];\n      if (ZenBlock.search(regClasses) === -1) {\n        return undefined;\n      }\n      classes = ZenBlock.match(regClasses);\n      clsString = \"\";\n      i = 0;\n      while (i < classes.length) {\n        clsString += \" \" + regClass.exec(classes[i])[1];\n        i++;\n      }\n      return $.trim(clsString);\n    };\n    parseContents = function(ZenBlock, data, indexes) {\n      var html;\n      if (indexes === undefined) {\n        indexes = {};\n      }\n      html = ZenBlock;\n      if (data === undefined) {\n        return html;\n      }\n      while (regExclamation.test(html)) {\n        html = html.replace(regExclamation, function(str, str2) {\n          var begChar, fn, val;\n          begChar = \"\";\n          if (str.indexOf(\"!for:\") > 0 || str.indexOf(\"!if:\") > 0) {\n            return str;\n          }\n          if (str.charAt(0) !== \"!\") {\n            begChar = str.charAt(0);\n            str = str.substring(2, str.length - 1);\n          }\n          fn = new Function(\"data\", \"indexes\", \"var r=undefined;\" + \"with(data){try{r=\" + str + \";}catch(e){}}\" + \"with(indexes){try{if(r===undefined)r=\" + str + \";}catch(e){}}\" + \"return r;\");\n          val = unescape(fn(data, indexes));\n          return begChar + val;\n        });\n      }\n      html = html.replace(/\\\\./g, function(str) {\n        return str.charAt(1);\n      });\n      return unescape(html);\n    };\n    parseEnclosure = function(ZenCode, open, close, count) {\n      var index, ret;\n      if (close === undefined) {\n        close = open;\n      }\n      index = 1;\n      if (count === undefined) {\n        count = (ZenCode.charAt(0) === open ? 1 : 0);\n      }\n      if (count === 0) {\n        return;\n      }\n      while (count > 0 && index < ZenCode.length) {\n        if (ZenCode.charAt(index) === close && ZenCode.charAt(index - 1) !== \"\\\\\") {\n          count--;\n        } else {\n          if (ZenCode.charAt(index) === open && ZenCode.charAt(index - 1) !== \"\\\\\") {\n            count++;\n          }\n        }\n        index++;\n      }\n      ret = ZenCode.substring(0, index);\n      return ret;\n    };\n    parseReferences = function(ZenCode, ZenObject) {\n      ZenCode = ZenCode.replace(regReference, function(str) {\n        var fn;\n        str = str.substr(1);\n        fn = new Function(\"objs\", \"var r=\\\"\\\";\" + \"with(objs){try{\" + \"r=\" + str + \";\" + \"}catch(e){}}\" + \"return r;\");\n        return fn(ZenObject, parseReferences);\n      });\n      return ZenCode;\n    };\n    parseVariableScope = function(ZenCode) {\n      var forCode, rest, tag;\n      if (ZenCode.substring(0, 5) !== \"!for:\" && ZenCode.substring(0, 4) !== \"!if:\") {\n        return undefined;\n      }\n      forCode = parseEnclosure(ZenCode, \"!\");\n      ZenCode = ZenCode.substr(forCode.length);\n      if (ZenCode.charAt(0) === \"(\") {\n        return parseEnclosure(ZenCode, \"(\", \")\");\n      }\n      tag = ZenCode.match(regZenTagDfn)[0];\n      ZenCode = ZenCode.substr(tag.length);\n      if (ZenCode.length === 0 || ZenCode.charAt(0) === \"+\") {\n        return tag;\n      } else if (ZenCode.charAt(0) === \">\") {\n        rest = \"\";\n        rest = parseEnclosure(ZenCode.substr(1), \"(\", \")\", 1);\n        return tag + \">\" + rest;\n      }\n      return undefined;\n    };\n    regZenTagDfn = /([#\\.\\@]?[\\w-]+|\\[([\\w-!?=:\"']+(=\"([^\"]|\\\\\")+\")? {0,})+\\]|\\~[\\w$]+=[\\w$]+|&[\\w$]+(=[\\w$]+)?|[#\\.\\@]?!([^!]|\\\\!)+!){0,}(\\{([^\\}]|\\\\\\})+\\})?/i;\n    regTag = /(\\w+)/i;\n    regId = /(?:^|\\b)#([\\w-!]+)/i;\n    regTagNotContent = /((([#\\.]?[\\w-]+)?(\\[([\\w!]+(=\"([^\"]|\\\\\")+\")? {0,})+\\])?)+)/i;\n    /*\n     See lookahead syntax (?!) at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n    */\n\n    regClasses = /(\\.[\\w-]+)(?![\"\\w])/g;\n    regClass = /\\.([\\w-]+)/i;\n    regReference = /(@[\\w$_][\\w$_\\d]+)/i;\n    regAttrDfn = /(\\[([\\w-!]+(=\"?([^\"]|\\\\\")+\"?)? {0,})+\\])/ig;\n    regAttrs = /([\\w-!]+(=\"([^\"]|\\\\\")+\")?)/g;\n    regAttr = /([\\w-!]+)(=\"?((([\\w]+(\\[.*?\\])+)|[^\"\\]]|\\\\\")+)\"?)?/i;\n    regCBrace = /\\{(([^\\}]|\\\\\\})+)\\}/i;\n    regExclamation = /(?:([^\\\\]|^))!([^!]|\\\\!)+!/g;\n    regEvents = /\\~[\\w$]+(=[\\w$]+)?/g;\n    regEvent = /\\~([\\w$]+)=([\\w$]+)/i;\n    regDatas = /&[\\w$]+(=[\\w$]+)?/g;\n    regData = /&([\\w$]+)(=([\\w$]+))?/i;\n    return createHTMLBlock;\n  })();\n\n}).call(this);\n",
    "/* jasmine-given - 2.6.3\n * Adds a Given-When-Then DSL to jasmine as an alternative style for specs\n * https://github.com/searls/jasmine-given\n */\n/* jasmine-matcher-wrapper - 0.0.3\n * Wraps Jasmine 1.x matchers for use with Jasmine 2\n * https://github.com/testdouble/jasmine-matcher-wrapper\n */\n(function() {\n  var __hasProp = {}.hasOwnProperty,\n    __slice = [].slice;\n\n  (function(jasmine) {\n    var comparatorFor, createMatcher;\n    if (jasmine == null) {\n      return typeof console !== \"undefined\" && console !== null ? console.warn(\"jasmine was not found. Skipping jasmine-matcher-wrapper. Verify your script load order.\") : void 0;\n    }\n    if (jasmine.matcherWrapper != null) {\n      return;\n    }\n    jasmine.matcherWrapper = {\n      wrap: function(matchers) {\n        var matcher, name, wrappedMatchers;\n        if (jasmine.addMatchers == null) {\n          return matchers;\n        }\n        wrappedMatchers = {};\n        for (name in matchers) {\n          if (!__hasProp.call(matchers, name)) continue;\n          matcher = matchers[name];\n          wrappedMatchers[name] = createMatcher(name, matcher);\n        }\n        return wrappedMatchers;\n      }\n    };\n    createMatcher = function(name, matcher) {\n      return function() {\n        return {\n          compare: comparatorFor(matcher, false),\n          negativeCompare: comparatorFor(matcher, true)\n        };\n      };\n    };\n    return comparatorFor = function(matcher, isNot) {\n      return function() {\n        var actual, context, message, params, pass, _ref;\n        actual = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        context = {\n          actual: actual,\n          isNot: isNot\n        };\n        pass = matcher.apply(context, params);\n        if (isNot) {\n          pass = !pass;\n        }\n        if (!pass) {\n          message = (_ref = context.message) != null ? _ref.apply(context, params) : void 0;\n        }\n        return {\n          pass: pass,\n          message: message\n        };\n      };\n    };\n  })(jasmine || getJasmineRequireObj());\n\n}).call(this);\n\n(function() {\n  var __slice = [].slice;\n\n  (function(jasmine) {\n    var Waterfall, additionalInsightsForErrorMessage, apparentReferenceError, attemptedEquality, cloneArray, comparisonInsight, currentSpec, declareJasmineSpec, deepEqualsNotice, doneWrapperFor, errorWithRemovedLines, evalInContextOfSpec, finalStatementFrom, getBlock, invariantList, mostRecentExpectations, mostRecentStacks, mostRecentlyUsed, o, root, stringifyExpectation, wasComparison, whenList, wrapAsExpectations;\n    mostRecentlyUsed = null;\n    root = (1, eval)('this');\n    currentSpec = null;\n    beforeEach(function() {\n      return currentSpec = this;\n    });\n    root.Given = function() {\n      mostRecentlyUsed = root.Given;\n      return beforeEach(getBlock(arguments));\n    };\n    whenList = [];\n    root.When = function() {\n      var b;\n      mostRecentlyUsed = root.When;\n      b = getBlock(arguments);\n      beforeEach(function() {\n        return whenList.push(b);\n      });\n      return afterEach(function() {\n        return whenList.pop();\n      });\n    };\n    invariantList = [];\n    root.Invariant = function() {\n      var invariantBehavior;\n      mostRecentlyUsed = root.Invariant;\n      invariantBehavior = getBlock(arguments);\n      beforeEach(function() {\n        return invariantList.push(invariantBehavior);\n      });\n      return afterEach(function() {\n        return invariantList.pop();\n      });\n    };\n    getBlock = function(thing) {\n      var assignResultTo, setupFunction;\n      setupFunction = o(thing).firstThat(function(arg) {\n        return o(arg).isFunction();\n      });\n      assignResultTo = o(thing).firstThat(function(arg) {\n        return o(arg).isString();\n      });\n      return doneWrapperFor(setupFunction, function(done) {\n        var context, result;\n        context = currentSpec;\n        result = setupFunction.call(context, done);\n        if (assignResultTo) {\n          if (!context[assignResultTo]) {\n            return context[assignResultTo] = result;\n          } else {\n            throw new Error(\"Unfortunately, the variable '\" + assignResultTo + \"' is already assigned to: \" + context[assignResultTo]);\n          }\n        }\n      });\n    };\n    mostRecentExpectations = null;\n    mostRecentStacks = null;\n    declareJasmineSpec = function(specArgs, itFunction) {\n      var expectationFunction, expectations, label, stacks;\n      if (itFunction == null) {\n        itFunction = it;\n      }\n      label = o(specArgs).firstThat(function(arg) {\n        return o(arg).isString();\n      });\n      expectationFunction = o(specArgs).firstThat(function(arg) {\n        return o(arg).isFunction();\n      });\n      mostRecentlyUsed = root.subsequentThen;\n      mostRecentExpectations = expectations = [expectationFunction];\n      mostRecentStacks = stacks = [errorWithRemovedLines(\"failed expectation\", 3)];\n      itFunction(\"then \" + (label != null ? label : stringifyExpectation(expectations)), doneWrapperFor(expectationFunction, function(jasmineDone) {\n        var userCommands;\n        userCommands = [].concat(whenList, invariantList, wrapAsExpectations(expectations, stacks));\n        return new Waterfall(userCommands, jasmineDone).flow();\n      }));\n      return {\n        Then: subsequentThen,\n        And: subsequentThen\n      };\n    };\n    wrapAsExpectations = function(expectations, stacks) {\n      var expectation, i, _i, _len, _results;\n      _results = [];\n      for (i = _i = 0, _len = expectations.length; _i < _len; i = ++_i) {\n        expectation = expectations[i];\n        _results.push((function(expectation, i) {\n          return doneWrapperFor(expectation, function(maybeDone) {\n            return expect(expectation).not.toHaveReturnedFalseFromThen(currentSpec, i + 1, stacks[i], maybeDone);\n          });\n        })(expectation, i));\n      }\n      return _results;\n    };\n    doneWrapperFor = function(func, toWrap) {\n      if (func.length === 0) {\n        return function() {\n          return toWrap();\n        };\n      } else {\n        return function(done) {\n          return toWrap(done);\n        };\n      }\n    };\n    root.Then = function() {\n      return declareJasmineSpec(arguments);\n    };\n    root.Then.only = function() {\n      return declareJasmineSpec(arguments, it.only);\n    };\n    root.subsequentThen = function(additionalExpectation) {\n      mostRecentExpectations.push(additionalExpectation);\n      mostRecentStacks.push(errorWithRemovedLines(\"failed expectation\", 3));\n      return this;\n    };\n    errorWithRemovedLines = function(msg, n) {\n      var error, lines, stack, _ref;\n      if (stack = new Error(msg).stack) {\n        _ref = stack.split(\"\\n\"), error = _ref[0], lines = 2 <= _ref.length ? __slice.call(_ref, 1) : [];\n        return \"\" + error + \"\\n\" + (lines.slice(n).join(\"\\n\"));\n      }\n    };\n    mostRecentlyUsed = root.Given;\n    root.And = function() {\n      return mostRecentlyUsed.apply(this, jasmine.util.argsToArray(arguments));\n    };\n    o = function(thing) {\n      return {\n        isFunction: function() {\n          return Object.prototype.toString.call(thing) === \"[object Function]\";\n        },\n        isString: function() {\n          return Object.prototype.toString.call(thing) === \"[object String]\";\n        },\n        firstThat: function(test) {\n          var i;\n          i = 0;\n          while (i < thing.length) {\n            if (test(thing[i]) === true) {\n              return thing[i];\n            }\n            i++;\n          }\n          return void 0;\n        }\n      };\n    };\n    Waterfall = (function() {\n      function Waterfall(functions, finalCallback) {\n        if (functions == null) {\n          functions = [];\n        }\n        this.finalCallback = finalCallback != null ? finalCallback : function() {};\n        this.functions = cloneArray(functions);\n      }\n\n      Waterfall.prototype.flow = function() {\n        var func,\n          _this = this;\n        if (this.functions.length === 0) {\n          return this.finalCallback();\n        }\n        func = this.functions.shift();\n        if (func.length > 0) {\n          return func(function() {\n            return _this.flow();\n          });\n        } else {\n          func();\n          return this.flow();\n        }\n      };\n\n      return Waterfall;\n\n    })();\n    cloneArray = function(a) {\n      return a.slice(0);\n    };\n    jasmine._given = {\n      matchers: {\n        toHaveReturnedFalseFromThen: function(context, n, stackTrace, done) {\n          var e, exception, result;\n          result = false;\n          exception = void 0;\n          try {\n            result = this.actual.call(context, done);\n          } catch (_error) {\n            e = _error;\n            exception = e;\n          }\n          this.message = function() {\n            var msg, stringyExpectation;\n            stringyExpectation = stringifyExpectation(this.actual);\n            msg = \"Then clause\" + (n > 1 ? \" #\" + n : \"\") + \" `\" + stringyExpectation + \"` failed by \";\n            if (exception) {\n              msg += \"throwing: \" + exception.toString();\n            } else {\n              msg += \"returning false\";\n            }\n            msg += additionalInsightsForErrorMessage(stringyExpectation);\n            if (stackTrace != null) {\n              msg += \"\\n\\n\" + stackTrace;\n            }\n            return msg;\n          };\n          return result === false;\n        }\n      },\n      __Waterfall__: Waterfall\n    };\n    stringifyExpectation = function(expectation) {\n      var matches;\n      matches = expectation.toString().replace(/\\n/g, '').match(/function\\s?\\(.*\\)\\s?{\\s*(return\\s+)?(.*?)(;)?\\s*}/i);\n      if (matches && matches.length >= 3) {\n        return matches[2].replace(/\\s+/g, ' ');\n      } else {\n        return \"\";\n      }\n    };\n    additionalInsightsForErrorMessage = function(expectationString) {\n      var comparison, expectation;\n      expectation = finalStatementFrom(expectationString);\n      if (comparison = wasComparison(expectation)) {\n        return comparisonInsight(expectation, comparison);\n      } else {\n        return \"\";\n      }\n    };\n    finalStatementFrom = function(expectationString) {\n      var multiStatement;\n      if (multiStatement = expectationString.match(/.*return (.*)/)) {\n        return multiStatement[multiStatement.length - 1];\n      } else {\n        return expectationString;\n      }\n    };\n    wasComparison = function(expectation) {\n      var comparator, comparison, left, right, s;\n      if (comparison = expectation.match(/(.*) (===|!==|==|!=|>|>=|<|<=) (.*)/)) {\n        s = comparison[0], left = comparison[1], comparator = comparison[2], right = comparison[3];\n        return {\n          left: left,\n          comparator: comparator,\n          right: right\n        };\n      }\n    };\n    comparisonInsight = function(expectation, comparison) {\n      var left, msg, right;\n      left = evalInContextOfSpec(comparison.left);\n      right = evalInContextOfSpec(comparison.right);\n      if (apparentReferenceError(left) && apparentReferenceError(right)) {\n        return \"\";\n      }\n      msg = \"\\n\\nThis comparison was detected:\\n  \" + expectation + \"\\n  \" + left + \" \" + comparison.comparator + \" \" + right;\n      if (attemptedEquality(left, right, comparison.comparator)) {\n        msg += \"\\n\\n\" + (deepEqualsNotice(comparison.left, comparison.right));\n      }\n      return msg;\n    };\n    apparentReferenceError = function(result) {\n      return /^<Error: \"ReferenceError/.test(result);\n    };\n    evalInContextOfSpec = function(operand) {\n      var e;\n      try {\n        return (function() {\n          return eval(operand);\n        }).call(currentSpec);\n      } catch (_error) {\n        e = _error;\n        return \"<Error: \\\"\" + ((e != null ? typeof e.message === \"function\" ? e.message() : void 0 : void 0) || e) + \"\\\">\";\n      }\n    };\n    attemptedEquality = function(left, right, comparator) {\n      var _ref;\n      if (!(comparator === \"==\" || comparator === \"===\")) {\n        return false;\n      }\n      if (((_ref = jasmine.matchersUtil) != null ? _ref.equals : void 0) != null) {\n        return jasmine.matchersUtil.equals(left, right);\n      } else {\n        return jasmine.getEnv().equals_(left, right);\n      }\n    };\n    deepEqualsNotice = function(left, right) {\n      return \"However, these items are deeply equal! Try an expectation like this instead:\\n  expect(\" + left + \").toEqual(\" + right + \")\";\n    };\n    return beforeEach(function() {\n      if (jasmine.addMatchers != null) {\n        return jasmine.addMatchers(jasmine.matcherWrapper.wrap(jasmine._given.matchers));\n      } else {\n        return this.addMatchers(jasmine._given.matchers);\n      }\n    });\n  })(jasmine);\n\n}).call(this);\n",
    "/* jasmine-only - 0.1.1\n * Exclusivity spec helpers for jasmine: `describe.only` and `it.only`\n * https://github.com/davemo/jasmine-only\n */\n(function() {\n  var __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  (function(jasmine) {\n    var describeOnly, env, itOnly, root;\n    root = (1, eval)('this');\n    env = jasmine.getEnv();\n    describeOnly = function(description, specDefinitions) {\n      var suite;\n      suite = new jasmine.Suite(this, description, null, this.currentSuite);\n      suite.exclusive_ = 1;\n      this.exclusive_ = Math.max(this.exclusive_, 1);\n      return this.describe_(suite, specDefinitions);\n    };\n    itOnly = function(description, func) {\n      var spec;\n      spec = this.it(description, func);\n      spec.exclusive_ = 2;\n      this.exclusive_ = 2;\n      return spec;\n    };\n    env.exclusive_ = 0;\n    env.describe = function(description, specDefinitions) {\n      var suite;\n      suite = new jasmine.Suite(this, description, null, this.currentSuite);\n      return this.describe_(suite, specDefinitions);\n    };\n    env.describe_ = function(suite, specDefinitions) {\n      var declarationError, e, parentSuite;\n      parentSuite = this.currentSuite;\n      if (parentSuite) {\n        parentSuite.add(suite);\n      } else {\n        this.currentRunner_.add(suite);\n      }\n      this.currentSuite = suite;\n      declarationError = null;\n      try {\n        specDefinitions.call(suite);\n      } catch (_error) {\n        e = _error;\n        declarationError = e;\n      }\n      if (declarationError) {\n        this.it(\"encountered a declaration exception\", function() {\n          throw declarationError;\n        });\n      }\n      this.currentSuite = parentSuite;\n      return suite;\n    };\n    env.specFilter = function(spec) {\n      return this.exclusive_ <= spec.exclusive_;\n    };\n    env.describe.only = function() {\n      return describeOnly.apply(env, arguments);\n    };\n    env.it.only = function() {\n      return itOnly.apply(env, arguments);\n    };\n    root.describe.only = function(description, specDefinitions) {\n      return env.describe.only(description, specDefinitions);\n    };\n    root.it.only = function(description, func) {\n      return env.it.only(description, func);\n    };\n    root.iit = root.it.only;\n    root.ddescribe = root.describe.only;\n    jasmine.Spec = (function(_super) {\n      __extends(Spec, _super);\n\n      function Spec(env, suite, description) {\n        this.exclusive_ = suite.exclusive_;\n        Spec.__super__.constructor.call(this, env, suite, description);\n      }\n\n      return Spec;\n\n    })(jasmine.Spec);\n    return jasmine.Suite = (function(_super) {\n      __extends(Suite, _super);\n\n      function Suite(env, suite, specDefinitions, parentSuite) {\n        this.exclusive_ = parentSuite && parentSuite.exclusive_ || 0;\n        Suite.__super__.constructor.call(this, env, suite, specDefinitions, parentSuite);\n      }\n\n      return Suite;\n\n    })(jasmine.Suite);\n  })(jasmine);\n\n}).call(this);\n",
    "/* jasmine-stealth - 0.0.17\n * Makes Jasmine spies a bit more robust\n * https://github.com/searls/jasmine-stealth\n */\n(function() {\n  var __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  (function() {\n    var Captor, fake, root, stubChainer, unfakes, whatToDoWhenTheSpyGetsCalled, _;\n    root = (1, eval)('this');\n    _ = function(obj) {\n      return {\n        each: function(iterator) {\n          var item, _i, _len, _results;\n          _results = [];\n          for (_i = 0, _len = obj.length; _i < _len; _i++) {\n            item = obj[_i];\n            _results.push(iterator(item));\n          }\n          return _results;\n        },\n        isFunction: function() {\n          return Object.prototype.toString.call(obj) === \"[object Function]\";\n        },\n        isString: function() {\n          return Object.prototype.toString.call(obj) === \"[object String]\";\n        }\n      };\n    };\n    root.spyOnConstructor = function(owner, classToFake, methodsToSpy) {\n      var fakeClass, spies;\n      if (methodsToSpy == null) {\n        methodsToSpy = [];\n      }\n      if (_(methodsToSpy).isString()) {\n        methodsToSpy = [methodsToSpy];\n      }\n      spies = {\n        constructor: jasmine.createSpy(\"\" + classToFake + \"'s constructor\")\n      };\n      fakeClass = (function() {\n        function _Class() {\n          spies.constructor.apply(this, arguments);\n        }\n\n        return _Class;\n\n      })();\n      _(methodsToSpy).each(function(methodName) {\n        spies[methodName] = jasmine.createSpy(\"\" + classToFake + \"#\" + methodName);\n        return fakeClass.prototype[methodName] = function() {\n          return spies[methodName].apply(this, arguments);\n        };\n      });\n      fake(owner, classToFake, fakeClass);\n      return spies;\n    };\n    unfakes = [];\n    afterEach(function() {\n      _(unfakes).each(function(u) {\n        return u();\n      });\n      return unfakes = [];\n    });\n    fake = function(owner, thingToFake, newThing) {\n      var originalThing;\n      originalThing = owner[thingToFake];\n      owner[thingToFake] = newThing;\n      return unfakes.push(function() {\n        return owner[thingToFake] = originalThing;\n      });\n    };\n    root.stubFor = root.spyOn;\n    jasmine.createStub = jasmine.createSpy;\n    jasmine.createStubObj = function(baseName, stubbings) {\n      var name, obj, stubbing;\n      if (stubbings.constructor === Array) {\n        return jasmine.createSpyObj(baseName, stubbings);\n      } else {\n        obj = {};\n        for (name in stubbings) {\n          stubbing = stubbings[name];\n          obj[name] = jasmine.createSpy(baseName + \".\" + name);\n          if (_(stubbing).isFunction()) {\n            obj[name].andCallFake(stubbing);\n          } else {\n            obj[name].andReturn(stubbing);\n          }\n        }\n        return obj;\n      }\n    };\n    whatToDoWhenTheSpyGetsCalled = function(spy) {\n      var matchesStub, priorPlan;\n      matchesStub = function(stubbing, args, context) {\n        switch (stubbing.type) {\n          case \"args\":\n            return jasmine.getEnv().equals_(stubbing.ifThis, jasmine.util.argsToArray(args));\n          case \"context\":\n            return jasmine.getEnv().equals_(stubbing.ifThis, context);\n        }\n      };\n      priorPlan = spy.plan;\n      return spy.andCallFake(function() {\n        var i, stubbing;\n        i = 0;\n        while (i < spy._stealth_stubbings.length) {\n          stubbing = spy._stealth_stubbings[i];\n          if (matchesStub(stubbing, arguments, this)) {\n            if (stubbing.satisfaction === \"callFake\") {\n              return stubbing.thenThat.apply(stubbing, arguments);\n            } else {\n              return stubbing.thenThat;\n            }\n          }\n          i++;\n        }\n        return priorPlan.apply(spy, arguments);\n      });\n    };\n    jasmine.Spy.prototype.whenContext = function(context) {\n      var spy;\n      spy = this;\n      spy._stealth_stubbings || (spy._stealth_stubbings = []);\n      whatToDoWhenTheSpyGetsCalled(spy);\n      return stubChainer(spy, \"context\", context);\n    };\n    jasmine.Spy.prototype.when = function() {\n      var ifThis, spy;\n      spy = this;\n      ifThis = jasmine.util.argsToArray(arguments);\n      spy._stealth_stubbings || (spy._stealth_stubbings = []);\n      whatToDoWhenTheSpyGetsCalled(spy);\n      return stubChainer(spy, \"args\", ifThis);\n    };\n    stubChainer = function(spy, type, ifThis) {\n      var addStubbing;\n      addStubbing = function(satisfaction) {\n        return function(thenThat) {\n          spy._stealth_stubbings.unshift({\n            type: type,\n            ifThis: ifThis,\n            satisfaction: satisfaction,\n            thenThat: thenThat\n          });\n          return spy;\n        };\n      };\n      return {\n        thenReturn: addStubbing(\"return\"),\n        thenCallFake: addStubbing(\"callFake\")\n      };\n    };\n    jasmine.Spy.prototype.mostRecentCallThat = function(callThat, context) {\n      var i;\n      i = this.calls.length - 1;\n      while (i >= 0) {\n        if (callThat.call(context || this, this.calls[i]) === true) {\n          return this.calls[i];\n        }\n        i--;\n      }\n    };\n    jasmine.Matchers.ArgThat = (function(_super) {\n      __extends(ArgThat, _super);\n\n      function ArgThat(matcher) {\n        this.matcher = matcher;\n      }\n\n      ArgThat.prototype.jasmineMatches = function(actual) {\n        return this.matcher(actual);\n      };\n\n      return ArgThat;\n\n    })(jasmine.Matchers.Any);\n    jasmine.Matchers.ArgThat.prototype.matches = jasmine.Matchers.ArgThat.prototype.jasmineMatches;\n    jasmine.argThat = function(expected) {\n      return new jasmine.Matchers.ArgThat(expected);\n    };\n    jasmine.Matchers.Capture = (function(_super) {\n      __extends(Capture, _super);\n\n      function Capture(captor) {\n        this.captor = captor;\n      }\n\n      Capture.prototype.jasmineMatches = function(actual) {\n        this.captor.value = actual;\n        return true;\n      };\n\n      return Capture;\n\n    })(jasmine.Matchers.Any);\n    jasmine.Matchers.Capture.prototype.matches = jasmine.Matchers.Capture.prototype.jasmineMatches;\n    Captor = (function() {\n      function Captor() {}\n\n      Captor.prototype.capture = function() {\n        return new jasmine.Matchers.Capture(this);\n      };\n\n      return Captor;\n\n    })();\n    return jasmine.captor = function() {\n      return new Captor();\n    };\n  })();\n\n}).call(this);\n"
  ]
}